# Нагрузочное тестирование

## Вопросы

1. Основы тестирования
   - Требования
   - Дефекты
   - Виды тестирования

2. МНТ
   - Назначение, почему это важно
   - Основные разделы

3. Введение в методологию НТ
 Типовой план работ по НТ
 Цели НТ
  Виды НТ
   Поиск максимальной производительности
   Проверка стабильности
   Стресс тесты
   Проверка стрессоустойчивости
   Проверка отказоустойчивости
   Проверка масштабируемости
   Объемное тестирование

4. Расчет профиля НТ
   - На основе аналитики
   - На основе статистики (по ЧПН)
   - Точность профиля
   - Случай с несколькими профилями (например, дневной и ночной)

5. Анализ архитектуры систем
  Промышленный и тестовый стенды
  Важность их сравнения
  Источники нагрузки
  Смежные системы
  Заглушки
  Протоколы сетевые
   Стек (TCP/IP)
   НТТР (состав запроса и ответа, основные методы, коды ответа)
   Стандарты обмена REST и SOAP
  Двузхвенная и трехзвенная архитектура
   Толстый и тонкий клиенты
  Основные компоненты тестируемых систем
   Front, Back, DB
   Микросервисная и монолитная архитектура
   Балансировщики
   Брокеры сообщений (MQ vs Kafka)

6. JMeter
6.1. Разработка скриптов
  Параметризация
  Корреляция
  Верификация
  Настройка pacing
6.2 Выполнение тестов
  Создание теста по профилю из МНТ
  Интеграция c InfluxDB+Grafana
  Распределенный запуск теста
6.3 Разбор результатов тестов
  Основные графики
  Порядок разбора результатов

7. Обзор средств мониторинга (Prometheus+Grafana, Telegraf+InfluxDB+Grafana)
8. Метрики, собираемые во время НТ (классификация и примеры наиболее важных)

9. [Базы данных](#базы-данных)
   - [Введение в БД (классификация и примеры)](#введение-в-бд-классификация-и-примеры)
   - [Терминология и нормальные формы](#терминология-и-нормальные-формы)
   - [SQL (DDL, DML, DCL, TCL)](#sql-ddl-dml-dcl-tcl)
   - [Select, Update, Insert, Trancate, Delete](#select-update-insert-trancate-delete)
   - [Индексы (плюсы и минусы)](#индексы-плюсы-и-минусы)
   - [View vs Table](#view-vs-table)
   - [Алиасы](#алиасы)
   - [Oracle, AWR](#oracle-awr)
   - [PostgreSQL, аналоги AWR](#postgresql-аналоги-awr)
   - [План запроса (как построить и зачем)](#план-запроса-как-построить-и-зачем)

10. Введение в заглушки
  Определение и назначение
  Плюсы и минусы использования
  Обзор инструментов и фрейворков

11. Создание отчетов НТ
  Основные разделы и связь с МНТ

12. [Основы программирования](#основы-программирования)
    - [Парадигмы ООП](#парадигмы-ооп)
    - [Классы и объекты](#классы-и-объекты)

13. Самопредставление
  О себе
  О выполненных в рамках школы работах

### Базы данных

#### Введение в БД (классификация и примеры)

#### Терминология и нормальные формы

#### SQL (DDL, DML, DCL, TCL)

#### Select, Update, Insert, Trancate, Delete

#### Индексы (плюсы и минусы)

#### View vs Table

#### Алиасы

#### Oracle, AWR

#### PostgreSQL, аналоги AWR

#### План запроса (как построить и зачем)

### Основы программирования

#### Парадигмы ООП

__Объектно-ориентированное программирование (ООП)__ — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

- объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;
- каждый объект является экземпляром определенного класса;
- классы образуют иерархии.

Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование, не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.

Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями. Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.

Оосновные принципы _ООП_:

- _Инкапсуляция_ - сокрытие реализации
- _Наследование_ - создание новой сущности на базе уже существующей
- _Полиморфизм_ - возможность иметь разные формы для одной и той же сущности
- _Абстракция_ - набор общих характеристик
  
__Инкапсуляция__ – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

__Наследование__ – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется _предком_, _базовым_ или _родительским_. Новый класс – _потомком_, _наследником_ или _производным_ классом.

__Полиморфизм__ – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования. Отсюда следует ключевая особенность полиморфизма - использование объекта производного класса, вместо объекта базового (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).

Полиморфизм бывает _динамическим_ (переопределение) и _статическим_ (перегрузка).

_Полиморфная переменная_, это переменная, которая может принимать значения разных типов, а _полиморфная функция_, это функция у которой хотя бы один аргумент является полиморфной переменной.
Выделяют два вида полиморфных функций:

- _ad hoc_, функция ведет себя по разному для разных типов аргументов (например, функция `draw()` — рисует по разному фигуры разных типов);
- _параметрический_, функция ведет себя одинаково для аргументов разных типов (например, функция `add()` — одинаково кладет в контейнер элементы разных типов).

_Абстрагирование_ – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые. Соответственно, __абстракция__ – это набор всех таких характеристик.

#### Классы и объекты

Класс — это тип данных, созданный пользователем. Он содержит разные свойства и методы, как, например, тип String или Integer. Класс — это «шаблон» для объекта, который описывает его свойства. Несколько похожих между собой объектов, например профили разных пользователей, будут иметь одинаковую структуру, а значит, принадлежать к одному классу.

Объект — это основная единица в ООП, представляющая собой экземпляр класса, сочетающий в себе данные (состояние) и методы (поведение) для работы с этими данными. Например, когда вы создаёте переменную типа String и присваиваете ей значение «Строка», то в памяти создаётся экземпляр класса String.
